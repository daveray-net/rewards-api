package net.daveray.rewardsapi.util;

import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.time.Month;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * DataWrangler generates sample data for transactions
 * 
 * @author Dave Ray Reizes <daveray@daveray.net>
 * @since November 2023
 */
public class DataWrangler{
   final static Logger logger = LoggerFactory.getLogger(DataLoader.class);

   //public static void main(String[] args){
   public static void generateJsonDatafile(Path pathToFile) {
	   logger.info("CommandLineRunner TransactionGenerator transactionGenerator in main");

	   //get a map of names and timestamps
	   Map<String, String> customerTimestamps = getCustomerTimestamps();

	   //stream the map and generate transaction data in json format
	   List<List<String>> json = customerTimestamps.keySet().stream()
			   .map( (k) -> { var v = customerTimestamps.get(k);
			   	              var i = getRandomCustomerId();
							  var j = generateCustomerTransactions(k, i, v); 
							  return j;
				   			} )
			   .collect(Collectors.toList());
	   			//logger.debug("CommandLineRunner TransactionGenerator json="+json);

	   //create a file path to write to 
	   //Path path = Path.of("src/main/resources/rewards-api_transaction-list.json").toAbsolutePath();
	   Path path = pathToFile;
	   logger.info("CommandLineRunner TransactionGenerator path="+path);

	   //write the generated json to file, fail if already exists
	   try{
		   Files.write(path, json.toString().getBytes(), StandardOpenOption.CREATE_NEW);          
	   }catch(Exception e){
		   logger.warn("CommandLineRunner TransactionGenerator Exception="+e);
	   }

   }


//from static sample data return a map of customer names with three months of random timestamps
//random names generated by https://www.randomlists.com/fake-name-generator
//timestamps generated by http://sqa.fyicenter.com/1000199_Random_Test_Timestamp_Generator.html
  static final Map<String, String> getCustomerTimestamps(){
  
  Map<String, String> customerTimestamps = new HashMap<>();   

  String name="Dean Pacheco";
  String timestamps = """
2023-09-17T21:01:08.110+09:30
2023-10-25T05:27:45.195+01:00
2023-10-17T03:43:03.291-04:00
2023-10-06T02:24:01.042+14:00
2023-08-06T00:31:40.447-10:00
2023-09-28T11:25:01.214+02:00
2023-09-25T02:30:28.665+01:00
2023-09-25T13:39:42.346+12:45
2023-08-31T08:18:59.643+05:00
2023-09-29T19:39:30.787-02:00
2023-10-13T21:26:28.598+07:00
2023-08-18T11:47:21.144-03:30
""";
  customerTimestamps.put(name,timestamps);

  name="Hope Griffith";
  timestamps = """  
2023-09-07T18:27:27.394-09:00
2023-10-08T06:32:40.863+05:00
2023-08-28T17:30:03.741-04:00
2023-08-17T02:29:46.286+08:45
2023-09-10T18:54:23.961-04:00
2023-10-03T09:24:01.831+08:00
2023-09-04T11:17:22.163-08:00
2023-09-17T13:06:07.756+10:00
2023-10-24T02:23:47.415-08:00
2023-08-23T20:32:36.786-07:00
2023-08-23T23:25:04.215+02:00
2023-10-12T17:16:35.103+08:00
2023-09-07T12:26:00.445+12:00
""";
  customerTimestamps.put(name,timestamps);

  name="Rayan Lin";
  timestamps="""
2023-10-17T16:11:22.387+05:30
2023-08-16T20:22:56.611-00:00
2023-08-17T22:43:22.507+01:00
2023-10-12T17:54:48.697-03:00
2023-09-18T07:48:52.757-07:00
2023-09-24T14:20:14.212+03:30
2023-09-19T09:04:58.356-06:00
2023-08-28T23:37:52.079-09:30
2023-09-10T13:36:13.560+05:30
2023-09-20T16:15:37.534+10:30
2023-09-22T23:06:52.809-06:00
2023-08-26T05:10:08.238-03:00
2023-08-01T15:38:26.909-05:00    
""";
  customerTimestamps.put(name,timestamps);


  name="Regina Hensley";
  timestamps="""
2023-09-12T22:04:55.910-12:00
2023-09-08T14:13:56.273+10:30
2023-09-24T12:14:57.273+04:30
2023-10-06T05:12:45.775-12:00
2023-09-14T02:00:47.340-01:00
2023-08-22T16:41:35.307+14:00
2023-10-13T13:40:10.316+03:30
2023-08-23T01:57:26.797+09:30
2023-09-23T18:44:44.352-08:00
2023-10-19T04:40:35.473+09:00
""";
  customerTimestamps.put(name,timestamps);

  name="Lucia Bowen";
  timestamps="""
2023-09-26T08:50:06.135-12:00
2023-09-20T12:58:10.521+04:30
2023-08-14T12:40:33.456-07:00
2023-08-06T13:14:05.479+12:00
2023-09-19T18:43:18.283+10:30
2023-09-19T21:10:04.739-03:00
""";
  customerTimestamps.put(name,timestamps);
  
  name="Austin Morales";
  timestamps="""
2023-08-21T07:51:30.912+11:00
2023-09-23T06:36:00.913-04:00
2023-09-05T20:05:18.588+12:45
2023-09-29T00:04:28.737+04:00
""";
  customerTimestamps.put(name,timestamps);

  name="Zayne Mann";
  timestamps="""
2023-10-29T20:58:56.549-12:00
2023-08-28T14:04:20.393+09:30
2023-08-30T16:19:28.175+04:00
2023-10-03T09:08:45.653+05:00
""";
  customerTimestamps.put(name,timestamps);

  name="Kenya Mendoza";
  timestamps="""
2023-10-09T22:48:36.289-06:00
2023-08-28T07:45:45.512-11:00
2023-10-28T11:30:13.008-11:00
2023-08-07T08:29:37.361-04:00
2023-09-26T06:43:05.156+13:45
""";
  customerTimestamps.put(name,timestamps);

  name="Alyvia Simmons";
  timestamps="""
2023-08-03T19:21:00.414+10:00
2023-08-19T01:37:38.751+02:00
2023-10-13T16:10:37.391-12:00
2023-08-02T21:04:06.076+01:00
2023-09-25T06:39:59.375-09:30
""";
  customerTimestamps.put(name,timestamps);

  name="Scarlet Barnett";
  timestamps="""
2023-09-13T04:32:25.333+10:00
2023-08-15T09:09:20.528-09:00
2023-10-19T20:52:48.265+03:00
""";
  customerTimestamps.put(name,timestamps);

  name="Alayna Collins";
  timestamps="""
2023-08-25T05:26:08.948-03:00
2023-08-11T12:52:25.524+05:30
2023-10-31T08:47:39.285-03:30
""";
  customerTimestamps.put(name,timestamps);

  name="Demarcus Oconnell";
  timestamps="""
2023-09-28T08:42:27.263+04:30
2023-09-22T19:13:34.773+13:45
""";
  customerTimestamps.put(name,timestamps);

  return customerTimestamps;
  }


//generate transactions in json format using a name and multiline string of timestamps
  static final List<String> generateCustomerTransactions(String name, String custId, String timestamps){
  
  //split the multiline string into a list of timestamps
  List<String> timelist = Stream.of(timestamps.split("\n")).collect(Collectors.toList());

  //"timestamp"="1700202277986L",
  //"month"="OCTOBER",
  //-- pardon my french, lemois - since month is a keyword 
  //  "\"lemois\": \""+ Month.of( getMonth( Instant.parse(s).toEpochMilli() )) +"\", "
  //-- add the value for ranges queries...
  //  "\"monid\": \""+ getMonth( Instant.parse(s).toEpochMilli() ) +"\", "
  List<String> timelongs = timelist.stream().map(    
    s -> "\"unixtime\": \""+Long.valueOf( Instant.parse(s).toEpochMilli() )+"\", " +
         "\"lemois\": \""+ Month.of( getMonth( Instant.parse(s).toEpochMilli() )) +"\", " +
         "\"monid\": \""+ getMonth( Instant.parse(s).toEpochMilli() ) +"\", "
    ).collect(Collectors.toList());
  
  //"\n{ "+s +
  //"\n{\"id\": \""+UUID.randomUUID()+"\", "+s +
  //"customer_id"="903034712",
  //"name"="Alyvia Simmons",
  //"amount"="495.00",
  List<String> jsonrecord=timelongs.stream().map(
    s -> 
    "\n{\"id\": \""+UUID.randomUUID()+"\", "+s +
    "\"customerId\": \""+custId+"\", " +
    "\"name\": \""+name+"\", " +
    "\"amount\": \""+getRandomAmount()+"\" "
    ).collect(Collectors.toList());
  
  //"} close bracket"
  jsonrecord=jsonrecord.stream().map(
    s -> ""+s+"}\n"
  ).collect(Collectors.toList());
  
  
  return jsonrecord;
  }


//generate a customerid for humans to use
   static final String getRandomCustomerId(){
       UUID _customerid = UUID.randomUUID();
       String customerid = Integer.valueOf(_customerid.hashCode()).toString();
       if(customerid.startsWith("-")){
         customerid=customerid.substring(1,customerid.length()-1);
       }
       return customerid;
   }


//counter for amount adjustment
    static int i=0;
//increment/decrement counter for amount adjustment
    static final int adjuster(){
       if(i<=5){
         //okay
       }
       if(i>6){
        //reset
        i=i-i;
       } 
      return i+1;
    }

//generate a random amount
    static final String getRandomAmount(){
       
       String amount = new BigDecimal(Integer.valueOf(
         Integer.min(ThreadLocalRandom.current().nextInt(), ThreadLocalRandom.current().nextInt())
         )).setScale(2).toString();

       //keep it under 1000
       amount = amount.substring(amount.length()-6);
       
       //trim leading zero's
       if(amount.startsWith("0")){
         amount = amount.substring(1, amount.length());
       }
       //adjust for too many 100's
       i=adjuster();
       if(amount.length() > i){
         amount = amount.substring(1, amount.length());
       }
       //trim leading zero's after adjustment
       if(amount.startsWith("0")){
         amount = amount.substring(1, amount.length());
       }
       //fix .00's after adjustment
       if(amount.startsWith(".")){
         amount = i+amount;
       }       

       return amount;
    }

	/** 
	 * getMonth(millis) 
	 * helper method to replace Deprecated 
	 * java.util.Date.getMonth(millis)
	 * 
	 * @param unixtime Long
	 * @return int representing the MONTH
	 */
	static final int getMonth(Long unixtime ) {
		   var c = Calendar.getInstance();
		   c.setTimeInMillis(unixtime);
		   return c.get(Calendar.MONTH);
	   };
	   

}
